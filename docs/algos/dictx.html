<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>exact_cover_solver.algos.dictx API documentation</title>
<meta name="description" content="Dictionary based implementation for algorithm X." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exact_cover_solver.algos.dictx</code></h1>
</header>
<section id="section-intro">
<p>Dictionary based implementation for algorithm X.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Dictionary based implementation for algorithm X.&#34;&#34;&#34;

from typing import List

from exact_cover_solver.algos import AlgorithmX, Solution
from exact_cover_solver.data_creators import SetCollection
from exact_cover_solver.datastructures.dictmatrix import (
    DictMatrix,
    ColumnDict,
    ColumnValue,
)


class DictX(AlgorithmX):
    &#34;&#34;&#34;Dictionary based implementation for algorithm X.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        super().__init__()

    def solve(self, matrix: DictMatrix) -&gt; List[Solution]:
        &#34;&#34;&#34;Solve which rows cover the given matrix.

        Clears solutions bookkeeping from previous runs, then calls
        recursive method.

        Args:
            matrix: Matrix representation implemented with dictionaries and sets.

        Returns:
            List of solutions. Each solution is a list of indexes of rows that will
                exactly cover the given matrix.

        Raises:
            ValueError: Error is raised if given matrix has wrong type.
        &#34;&#34;&#34;
        if not isinstance(matrix, DictMatrix):
            raise ValueError(&#34;Given matrix can&#39;t be processed by DictX algorithm.&#34;)
        self._solutions.clear()
        column_dict, set_collection = matrix.data
        self._search(column_dict, set_collection)
        return self._solutions

    def _search(
        self,
        column_dict: ColumnDict,
        set_collection: SetCollection,
        partial: Solution = None,
    ) -&gt; None:
        &#34;&#34;&#34;Perform algorithm X recursively and collect solutions.

        Args:
            column_dict: Matrix representation as a dictionary.
            set_collection: Original set collection used to create the matrix.
            partial: List including rows collected this far in recursion.
        &#34;&#34;&#34;
        if not partial:
            partial: Solution = []

        if not column_dict:
            self._solutions.append(partial[:])
            return

        column = self._choose_optimal_column(column_dict)
        for row in column_dict[column]:
            partial.append(row)
            removed_columns = self._cover(column_dict, set_collection, row)
            self._search(column_dict, set_collection, partial)
            self._uncover(column_dict, set_collection, row, removed_columns)
            partial.pop()

    @staticmethod
    def _choose_optimal_column(column_dict: ColumnDict) -&gt; int:
        &#34;&#34;&#34;Find column with smallest size to minimize the branching factor.

        Args:
            column_dict: Dictionary of each column on current iteration.

        Returns:
            Key of optimal column.
        &#34;&#34;&#34;
        key, size = None, None
        for column, content in column_dict.items():
            if not key and not size:
                key, size = column, len(content)
            key, size = (column, len(content)) if len(content) &lt; size else (key, size)
        return key

    @staticmethod
    def _cover(
        column_dict: ColumnDict, set_collection: SetCollection, set_index: int
    ) -&gt; List[ColumnValue]:
        &#34;&#34;&#34;Cover columns in given set.

        Go through each element in given set and for each row where element is present,
        remove all other elements. Then remove column representing iterated element
        from column dictionary.

        Args:
            column_dict: Matrix representation as a dictionary
            set_collection: Original set collection used to create the matrix
            set_index: Which set elements to cover

        Returns:
            List including sets that have been removed from column dict.
        &#34;&#34;&#34;
        removed_columns = []
        for element in set_collection[set_index]:
            for row in column_dict[element]:
                for other_element in set_collection[row]:
                    if other_element != element:
                        column_dict[other_element].remove(row)
            removed_columns.append(column_dict.pop(element))
        return removed_columns

    @staticmethod
    def _uncover(
        column_dict: ColumnDict,
        set_collection: SetCollection,
        set_index: int,
        removed_columns: List[ColumnValue],
    ) -&gt; None:
        &#34;&#34;&#34;Uncover columns.

        Restores removed columns in reversed order to dictionary.
        Args:
            column_dict: Matrix representation as a dictionary
            set_collection: Original set collection used to create the matrix
            set_index: Which set elements to uncover
            removed_columns: Columns removed while covering set
        &#34;&#34;&#34;
        for counter, element in enumerate(reversed(set_collection[set_index])):
            index = len(removed_columns) - 1 - counter
            column_dict[element] = removed_columns[index]
            for row in column_dict[element]:
                for other_element in set_collection[row]:
                    if other_element != element:
                        column_dict[other_element].add(row)


# Add all private methods to pdoc when generating documentation
__pdoc__ = {
    f&#34;DictX.{func}&#34;: True
    for func in dir(DictX)
    if callable(getattr(DictX, func)) and func.startswith(&#34;_&#34;)
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exact_cover_solver.algos.dictx.DictX"><code class="flex name class">
<span>class <span class="ident">DictX</span></span>
</code></dt>
<dd>
<div class="desc"><p>Dictionary based implementation for algorithm X.</p>
<p>Initialize with empty solution counter and matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictX(AlgorithmX):
    &#34;&#34;&#34;Dictionary based implementation for algorithm X.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        super().__init__()

    def solve(self, matrix: DictMatrix) -&gt; List[Solution]:
        &#34;&#34;&#34;Solve which rows cover the given matrix.

        Clears solutions bookkeeping from previous runs, then calls
        recursive method.

        Args:
            matrix: Matrix representation implemented with dictionaries and sets.

        Returns:
            List of solutions. Each solution is a list of indexes of rows that will
                exactly cover the given matrix.

        Raises:
            ValueError: Error is raised if given matrix has wrong type.
        &#34;&#34;&#34;
        if not isinstance(matrix, DictMatrix):
            raise ValueError(&#34;Given matrix can&#39;t be processed by DictX algorithm.&#34;)
        self._solutions.clear()
        column_dict, set_collection = matrix.data
        self._search(column_dict, set_collection)
        return self._solutions

    def _search(
        self,
        column_dict: ColumnDict,
        set_collection: SetCollection,
        partial: Solution = None,
    ) -&gt; None:
        &#34;&#34;&#34;Perform algorithm X recursively and collect solutions.

        Args:
            column_dict: Matrix representation as a dictionary.
            set_collection: Original set collection used to create the matrix.
            partial: List including rows collected this far in recursion.
        &#34;&#34;&#34;
        if not partial:
            partial: Solution = []

        if not column_dict:
            self._solutions.append(partial[:])
            return

        column = self._choose_optimal_column(column_dict)
        for row in column_dict[column]:
            partial.append(row)
            removed_columns = self._cover(column_dict, set_collection, row)
            self._search(column_dict, set_collection, partial)
            self._uncover(column_dict, set_collection, row, removed_columns)
            partial.pop()

    @staticmethod
    def _choose_optimal_column(column_dict: ColumnDict) -&gt; int:
        &#34;&#34;&#34;Find column with smallest size to minimize the branching factor.

        Args:
            column_dict: Dictionary of each column on current iteration.

        Returns:
            Key of optimal column.
        &#34;&#34;&#34;
        key, size = None, None
        for column, content in column_dict.items():
            if not key and not size:
                key, size = column, len(content)
            key, size = (column, len(content)) if len(content) &lt; size else (key, size)
        return key

    @staticmethod
    def _cover(
        column_dict: ColumnDict, set_collection: SetCollection, set_index: int
    ) -&gt; List[ColumnValue]:
        &#34;&#34;&#34;Cover columns in given set.

        Go through each element in given set and for each row where element is present,
        remove all other elements. Then remove column representing iterated element
        from column dictionary.

        Args:
            column_dict: Matrix representation as a dictionary
            set_collection: Original set collection used to create the matrix
            set_index: Which set elements to cover

        Returns:
            List including sets that have been removed from column dict.
        &#34;&#34;&#34;
        removed_columns = []
        for element in set_collection[set_index]:
            for row in column_dict[element]:
                for other_element in set_collection[row]:
                    if other_element != element:
                        column_dict[other_element].remove(row)
            removed_columns.append(column_dict.pop(element))
        return removed_columns

    @staticmethod
    def _uncover(
        column_dict: ColumnDict,
        set_collection: SetCollection,
        set_index: int,
        removed_columns: List[ColumnValue],
    ) -&gt; None:
        &#34;&#34;&#34;Uncover columns.

        Restores removed columns in reversed order to dictionary.
        Args:
            column_dict: Matrix representation as a dictionary
            set_collection: Original set collection used to create the matrix
            set_index: Which set elements to uncover
            removed_columns: Columns removed while covering set
        &#34;&#34;&#34;
        for counter, element in enumerate(reversed(set_collection[set_index])):
            index = len(removed_columns) - 1 - counter
            column_dict[element] = removed_columns[index]
            for row in column_dict[element]:
                for other_element in set_collection[row]:
                    if other_element != element:
                        column_dict[other_element].add(row)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exact_cover_solver.algos.AlgorithmX" href="index.html#exact_cover_solver.algos.AlgorithmX">AlgorithmX</a></li>
<li>abc.ABC</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exact_cover_solver.algos.dictx.DictX._choose_optimal_column"><code class="name flex">
<span>def <span class="ident">_choose_optimal_column</span></span>(<span>column_dict: Dict[int, Set[int]]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Find column with smallest size to minimize the branching factor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column_dict</code></strong></dt>
<dd>Dictionary of each column on current iteration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Key of optimal column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _choose_optimal_column(column_dict: ColumnDict) -&gt; int:
    &#34;&#34;&#34;Find column with smallest size to minimize the branching factor.

    Args:
        column_dict: Dictionary of each column on current iteration.

    Returns:
        Key of optimal column.
    &#34;&#34;&#34;
    key, size = None, None
    for column, content in column_dict.items():
        if not key and not size:
            key, size = column, len(content)
        key, size = (column, len(content)) if len(content) &lt; size else (key, size)
    return key</code></pre>
</details>
</dd>
<dt id="exact_cover_solver.algos.dictx.DictX._cover"><code class="name flex">
<span>def <span class="ident">_cover</span></span>(<span>column_dict: Dict[int, Set[int]], set_collection: List[List[int]], set_index: int) ‑> List[Set[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Cover columns in given set.</p>
<p>Go through each element in given set and for each row where element is present,
remove all other elements. Then remove column representing iterated element
from column dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column_dict</code></strong></dt>
<dd>Matrix representation as a dictionary</dd>
<dt><strong><code>set_collection</code></strong></dt>
<dd>Original set collection used to create the matrix</dd>
<dt><strong><code>set_index</code></strong></dt>
<dd>Which set elements to cover</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List including sets that have been removed from column dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _cover(
    column_dict: ColumnDict, set_collection: SetCollection, set_index: int
) -&gt; List[ColumnValue]:
    &#34;&#34;&#34;Cover columns in given set.

    Go through each element in given set and for each row where element is present,
    remove all other elements. Then remove column representing iterated element
    from column dictionary.

    Args:
        column_dict: Matrix representation as a dictionary
        set_collection: Original set collection used to create the matrix
        set_index: Which set elements to cover

    Returns:
        List including sets that have been removed from column dict.
    &#34;&#34;&#34;
    removed_columns = []
    for element in set_collection[set_index]:
        for row in column_dict[element]:
            for other_element in set_collection[row]:
                if other_element != element:
                    column_dict[other_element].remove(row)
        removed_columns.append(column_dict.pop(element))
    return removed_columns</code></pre>
</details>
</dd>
<dt id="exact_cover_solver.algos.dictx.DictX._uncover"><code class="name flex">
<span>def <span class="ident">_uncover</span></span>(<span>column_dict: Dict[int, Set[int]], set_collection: List[List[int]], set_index: int, removed_columns: List[Set[int]]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Uncover columns.</p>
<p>Restores removed columns in reversed order to dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column_dict</code></strong></dt>
<dd>Matrix representation as a dictionary</dd>
<dt><strong><code>set_collection</code></strong></dt>
<dd>Original set collection used to create the matrix</dd>
<dt><strong><code>set_index</code></strong></dt>
<dd>Which set elements to uncover</dd>
<dt><strong><code>removed_columns</code></strong></dt>
<dd>Columns removed while covering set</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def _uncover(
    column_dict: ColumnDict,
    set_collection: SetCollection,
    set_index: int,
    removed_columns: List[ColumnValue],
) -&gt; None:
    &#34;&#34;&#34;Uncover columns.

    Restores removed columns in reversed order to dictionary.
    Args:
        column_dict: Matrix representation as a dictionary
        set_collection: Original set collection used to create the matrix
        set_index: Which set elements to uncover
        removed_columns: Columns removed while covering set
    &#34;&#34;&#34;
    for counter, element in enumerate(reversed(set_collection[set_index])):
        index = len(removed_columns) - 1 - counter
        column_dict[element] = removed_columns[index]
        for row in column_dict[element]:
            for other_element in set_collection[row]:
                if other_element != element:
                    column_dict[other_element].add(row)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exact_cover_solver.algos.dictx.DictX.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with empty solution counter and matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(self) -&gt; None:
    super().__init__()</code></pre>
</details>
</dd>
<dt id="exact_cover_solver.algos.dictx.DictX._search"><code class="name flex">
<span>def <span class="ident">_search</span></span>(<span>self, column_dict: Dict[int, Set[int]], set_collection: List[List[int]], partial: List[int] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Perform algorithm X recursively and collect solutions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column_dict</code></strong></dt>
<dd>Matrix representation as a dictionary.</dd>
<dt><strong><code>set_collection</code></strong></dt>
<dd>Original set collection used to create the matrix.</dd>
<dt><strong><code>partial</code></strong></dt>
<dd>List including rows collected this far in recursion.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _search(
    self,
    column_dict: ColumnDict,
    set_collection: SetCollection,
    partial: Solution = None,
) -&gt; None:
    &#34;&#34;&#34;Perform algorithm X recursively and collect solutions.

    Args:
        column_dict: Matrix representation as a dictionary.
        set_collection: Original set collection used to create the matrix.
        partial: List including rows collected this far in recursion.
    &#34;&#34;&#34;
    if not partial:
        partial: Solution = []

    if not column_dict:
        self._solutions.append(partial[:])
        return

    column = self._choose_optimal_column(column_dict)
    for row in column_dict[column]:
        partial.append(row)
        removed_columns = self._cover(column_dict, set_collection, row)
        self._search(column_dict, set_collection, partial)
        self._uncover(column_dict, set_collection, row, removed_columns)
        partial.pop()</code></pre>
</details>
</dd>
<dt id="exact_cover_solver.algos.dictx.DictX.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self, matrix: <a title="exact_cover_solver.datastructures.dictmatrix.DictMatrix" href="../datastructures/dictmatrix.html#exact_cover_solver.datastructures.dictmatrix.DictMatrix">DictMatrix</a>) ‑> List[List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Solve which rows cover the given matrix.</p>
<p>Clears solutions bookkeeping from previous runs, then calls
recursive method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix representation implemented with dictionaries and sets.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of solutions. Each solution is a list of indexes of rows that will
exactly cover the given matrix.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Error is raised if given matrix has wrong type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self, matrix: DictMatrix) -&gt; List[Solution]:
    &#34;&#34;&#34;Solve which rows cover the given matrix.

    Clears solutions bookkeeping from previous runs, then calls
    recursive method.

    Args:
        matrix: Matrix representation implemented with dictionaries and sets.

    Returns:
        List of solutions. Each solution is a list of indexes of rows that will
            exactly cover the given matrix.

    Raises:
        ValueError: Error is raised if given matrix has wrong type.
    &#34;&#34;&#34;
    if not isinstance(matrix, DictMatrix):
        raise ValueError(&#34;Given matrix can&#39;t be processed by DictX algorithm.&#34;)
    self._solutions.clear()
    column_dict, set_collection = matrix.data
    self._search(column_dict, set_collection)
    return self._solutions</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exact_cover_solver.algos" href="index.html">exact_cover_solver.algos</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exact_cover_solver.algos.dictx.DictX" href="#exact_cover_solver.algos.dictx.DictX">DictX</a></code></h4>
<ul class="">
<li><code><a title="exact_cover_solver.algos.dictx.DictX.__init__" href="#exact_cover_solver.algos.dictx.DictX.__init__">__init__</a></code></li>
<li><code><a title="exact_cover_solver.algos.dictx.DictX._choose_optimal_column" href="#exact_cover_solver.algos.dictx.DictX._choose_optimal_column">_choose_optimal_column</a></code></li>
<li><code><a title="exact_cover_solver.algos.dictx.DictX._cover" href="#exact_cover_solver.algos.dictx.DictX._cover">_cover</a></code></li>
<li><code><a title="exact_cover_solver.algos.dictx.DictX._search" href="#exact_cover_solver.algos.dictx.DictX._search">_search</a></code></li>
<li><code><a title="exact_cover_solver.algos.dictx.DictX._uncover" href="#exact_cover_solver.algos.dictx.DictX._uncover">_uncover</a></code></li>
<li><code><a title="exact_cover_solver.algos.dictx.DictX.solve" href="#exact_cover_solver.algos.dictx.DictX.solve">solve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>